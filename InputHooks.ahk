class CustomInputHook extends InputHook {
    /**
     * Create an object that can be used to collect or intercept keyboard input.
     * @param Options A string consisting of zero or more of the following letters (in any order, with optional spaces in between):
     * 
     * B: Set BackspaceIsUndo to false, which will cause Backspace to be ignored.
     * 
     * C: Set CaseSensitive to true to make MatchList case sensitive.
     * 
     * I: Set MinSendLevel to 1 or a given value, so that any input with an input level lower than this value is ignored. For example, I2 will ignore any input with level 0 (default) or 1, but will capture any input with level 2 enter.
     * 
     * L: Length limit (such as L5). The maximum allowable length of the input. When the text reaches this length, the input is terminated and EndReason is set to the word Max (unless the text matches a phrase in the MatchList, in which case EndReason is Set to the word Match). If not specified, the length is limited to 1023.
     * 
     * Specify L0 to disable the collection of text and the length limit, but it does not affect the statistics of the text generated by the key (see VisibleText). This can be used in combination with OnChar, OnKeyDown, KeyOpt or EndKeys.
     * 
     * M: Recognize and transcribe modifier keystrokes corresponding to real ASCII characters (such as Ctrl+A to Ctrl+Z). Refer to this example, it recognizes Ctrl+C:
     * 
     * T: Set Timeout (e.g. T3 or T2.5).
     * 
     * V: Set VisibleText and VisibleNonText to true. Normally, user input is blocked (hidden from the system). Use this option to send the user's keystrokes to the active window.
     * 
     * Â·*: Wildcard. Set FindAnywhere to true to allow matches to be found anywhere the user types.
     * 
     * E: Handling single-character end keys by character code instead of key code. If the keyboard layout of the active window is different from that of the script, it can provide more consistent results. It also prevents the given end character from actually being generated The key combination to end Input; for example, if @ is the end key, Shift+2 will trigger it on the American keyboard, but Ctrl+Shift+2 will not trigger (when using the E option). If you also use C Option, the ending character is case sensitive.
     * @param EndKeys A list of zero or more keys, where any key terminates input when pressed (the end key itself will not be written into the input buffer). When Input is terminated in this way, EndReason is set to The word EndKey, EndKey properties are set to the name of the key.
     * 
     * The EndKeys list uses a format similar to the Send function. For example, specifying {Enter}.{Esc} will cause either Enter,. Or Esc to terminate the Input. Using the brace itself as the end key, specify {{} and /or{}}.
     * 
     * To use Ctrl, Alt or Shift as the end key, please specify the left and/or right version of the key instead of the neutral version. For example, specify {LControl}{RControl} instead of (Control).
     * 
     * Although modifier keys such as Alt+C(!c) are not supported, instead of alphanumeric characters (such as?!:@&()) by default, the Shift key is required to be pressed or not, depending on the normal input of characters Method. If there is an E option, a single character key name is interpreted as a character. In this case, the modifier key must be in the correct state to generate the character. When the E and M options are used at the same time, by including in EndKeys Corresponding ASCII control characters to support Ctrl+A to Ctrl+Z.
     * 
     * You can also specify a clear virtual key code, such as {vkFF} or {sc001}. This is very useful in rare cases where the key has no name and does not produce visible characters when pressed. Its virtual key code can be found at the bottom of the key list page The steps to determine.
     * @param MatchList is a comma-separated list of keywords, any of which will cause the input to be terminated (in this case, EndReason will be set to the word Match). The content entered by the user must exactly match a certain phrase in the match list (Unless there is an * option). In addition, any spaces or tabs around the delimiter comma are meaningful, which means they are part of the matching string. For example, if MatchList is ABC, XYZ, then the user must Type a space after ABC or before XYZ to form a match.
     * 
     * Two consecutive commas produce a single literal comma. For example, the following match list will produce a single literal comma at the end of string1: string1,,,string2. Similarly, the following match list contains only one literal comma Single item: single,,item.
     * 
     * Because the items in MatchList are not treated as separate parameters, the list can be completely contained in a variable. In fact, if the length of this list exceeds 16383, then all or part of the list must be contained in the variable because of this length Is the maximum length of any script line. For example, MatchList may consist of List1 "," List2 "," List3 - each of these variables contains a sublist of matching phrases.
     */
    __New(Options?, EndKeys?, MatchList?) {
        super.__New(Options?, EndKeys?, MatchList?)

        this.Initialise()
    }

    SelfOnEnd := ""
    SelfOnChar := ""
    SelfOnKeyDown := ""
    SelfOnKeyUp := ""
    InnerOnEnd := ""
    InnerOnChar := ""
    InnerOnKeyDown := ""
    InnerOnKeyUp := ""

    OnEnd {
        get => this.InnerOnEnd
        set => this.InnerOnEnd := value
    }

    OnChar {
        get => this.InnerOnChar
        set => this.InnerOnChar := value
    }

    OnKeyDown {
        get => this.InnerOnKeyDown
        set => this.InnerOnKeyDown := value
    }

    OnKeyUp {
        get => this.InnerOnKeyUp
        set => this.InnerOnKeyUp := value
    }

    Initialise() {
        DoForSelf(IH, Name, DoFn) {
            if (ObjHasOwnProp(IH, "Self" . Name)) {
                val := IH.%"Self" . Name%
                if (val.HasMethod())
                    DoFn(val)
            }

            if (ObjHasOwnProp(IH, "Inner" . Name)) {
                val := IH.%"Self" . Name%
                if (val.HasMethod())
                    DoFn(val)
            }
        }

        super.OnEnd := (IH) => DoForSelf(IH, "OnEnd", (fn) => fn(IH))
        super.OnChar := (IH, Char) => DoForSelf(IH, "OnChar", (fn) => fn(IH, Char))
        super.OnKeyDown := (IH, VK, SC) => DoForSelf(IH, "OnKeyDown", (fn) => fn(IH, VK, SC))
        super.OnKeyUp := (IH, VK, SC) => DoForSelf(IH, "OnKeyUp", (fn) => fn(IH, VK, SC))
    }
}

/**
 * @extends {CustomInputHook}
 */
class SuspendingInputHook extends CustomInputHook {
    Initialise() {
        this.SelfOnEnd := this.__SelfOnEnd
    }

    __SelfOnEnd() {
        if (ObjHasOwnProp(this, "WasSuspended")) {
            if (!this.WasSuspended) {
                Suspend false
            }
        } else {
            Suspend false
        }
    }

    Start() {
        this.WasSuspended := A_IsSuspended
        Suspend true
        super.Start()
    }
}

/**
 * @extends {CustomInputHook}
 */
class NoSemiInputHook extends CustomInputHook {
    EndChars := ""

    Initialise() {
        this.SelfOnEnd := this.__SelfOnEnd
    }


    __SelfOnEnd() {
        if (ObjHasOwnProp(this, "EndChars") && this.EndChars != "") {
            Hotstring("EndChars", this.EndChars)
        }
    }

    Start() {
        this.EndChars := Hotstring("EndChars")
        Hotstring("EndChars", StrReplace(this.EndChars, ";", ""))
        super.Start()
    }
}